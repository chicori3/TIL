# 포인터

## 포인터 이해

### 1. 포인터 개념

- 포인터 : 특정 위치를 가리키는 주소 정보
- 포인터 변수 : 포인터를 저장하는 변수
- 포인터 변수의 역할은 다른 변수를 가리키는 변수
> 포인터 변수의 크기는 일반적으로 4byte

### 2. 포인터 변수

포인터 변수의 데이터 타입은 포인팅하는 변수의 데이터 타입과 동일한 타입으로 선언

`데이터타입 * 포인터 변수명;`

#### sizeof() 연산자
int sizeof(int) : 매개변수에 기술한 공간의 크기를 정수값으로 반환

### 3. 포인터 초기화

- & : 주소 구하기 연산자
- &데이터 변수 : 변수의 주소를 의미
- *포인터 변수 : 포인터 변수가 가리키는 주소의 값

```c++
int x = 7;        // 변수의 선언
int *ptr = &x;    // 포인터의 선언
int *pptr = &ptr; // 포인터의 참조
```

## 포인터 이용

### 1. 포인터 다루기

```c++
// 사용자에게 입력받은 해당 값을 2배로 바꿔 출력하기
void ChangeDouble(int* p) {     // int* p = &num;
	*p = *p * 2;

}

int main(void) {
	int num;
	printf("숫자 입력 : ");
	scanf("%d", &num);          // scanf의 &num은 변수 num의 주소라는 의미
	ChangeDouble(&num);
	printf("%d\n", num);
	return 0;
}

```

### 2. 이중 포인터

- 포인터 변수의 주소를 저장하는 포인터 변수
- 이중 포인터를 이용하려면 **처럼 두 번 간접 참조해야 함

```c++
int x;
int *p = &x;
int **pp = &p;  // 이중 포인터
```

### 3. 포인터 오류

- 포인터도 변수이므로 반드시 초기화 해야 함
- 포인터 변수를 초기화하지 않으면 에러 발생
- 널 포인터 : 포인터가 다른 변수를 가리키지 않을 때는 **NULL(0)**로 초기화
- 포인터를 안전하게 사용하려면 널 포인터인지 우선 검사
- 포인터 변수의 데이터 타입은 가리키는 데이터 타입과 일치해야 함

## 포인터 활용

### 1. 포인터로 배열 참조

1. 배열의 시작 주소를 구할 때는 **& 없이 배열명**만 사용
2. 배열의 시작 주소는 첫 번째 원소의 주소와 같음
3. 배열명을 포인터처럼 사용 가능
4. `* (arr+i)`는 `arr[i]`를 의미
5. 배열의 시작 주소로 초기화된 포인터를 이용해 배열의 모든 원소에 접근 가능
6. 포인터 변수를 배열명처럼 사용 가능
7. 포인터와 +, - 연산
    > 데이터 타입의 크기만큼 주소가 증가, 감소함

```c++
`int arr[5]={12,25,37,49,53}; int *p=arr;`

|식|답
|:--|--:
|*p+1|13
|*(p+2)|37
|arr+3|arr[3]의 주소
|*(arr+3)|49
|*arr+4|16
|p[4]|53
|&arr[2]|arr[2]의 주소
|p+3|arr[3]의 주소
```

### 2. 포인터와 배열 원소

1. 배열의 원소를 가리키는 포인터는 **배열의 어떤 원소든 가리킬 수 있음**

```c++
int arr[5] = {10, 20, 30, 40, 50};

int *p = &arr[2];           // p는 arr[2]를 가리킴
printf(“p[0] = %d”, p[0]);  // p[0]은 arr[2]를 의미하므로 30을 출력함
printf(“p[1] = %d”, p[1]);  // p[1]은 arr[3]를 의미하므로 40을 출력함
```

2. 포인터가 배열의 원소가 아닌 일반 변수를 가리킬 때도 `*(p+i) == p[i]`는 항상 성립

```c++
short data = 10;
short *ptr = &data;
ptr[0] = 20;                // *p 대신 p[0]처럼 사용할 수 있음
```

> 배열이 메모리에 할당되고 나면, 배열의 시작 주소 변경 불가
> 포인터 변수는 값을 변경할 수 있으므로, 포인터 변수에 보관된 주소는 변경 가능

## 포인터 연산

포인터에 대한 증감연산도 포인터형에 의해 연산의 결과 결정

> 우선 순위 : p++ > ++p = *

## 포인터 배열 처리

포인터 배열 : 주소를 저장하는 배열

### 1. 포인터 배열의 각 원소에 **배열의 시작 주소**를 저장할 수 있음

```c++
int x[3] = {1, 2, 3};
int y[3] = {4, 5, 6};
int z[3] = {7, 8, 9};
int* arr[3] = {x, y, z};    // 포인터 배열의 원소를 int 배열의 시작 주소로 초기화
```

### 2. arr[i]가 int 배열의 시작 주소로 초기화되었을 때, arr[i]가 가리키는 배열의 원소에 접근하려면 `arr[i][j]`로 기술

```c++
for( i = 0 ; i < 3 ; i++ )
{
    for( j = 0 ; j < 3 ; j++ )
    printf( “%d”, arr[i][j] );  // *(arr[i]+[j])와 같은 의미
    printf( “＼n” );
}

```
# 포인터

## 포인터 이해

### 1. 포인터 개념

- 포인터 : 특정 위치를 가리키는 주소 정보
- 포인터 변수 : 포인터를 저장하는 변수
- 포인터 변수의 역할은 다른 변수를 가리키는 변수
> 포인터 변수의 크기는 일반적으로 4byte

### 2. 포인터 변수

포인터 변수의 데이터 타입은 포인팅하는 변수의 데이터 타입과 동일한 타입으로 선언

`데이터타입 * 포인터 변수명;`

#### sizeof() 연산자
int sizeof(int) : 매개변수에 기술한 공간의 크기를 정수값으로 반환

### 3. 포인터 초기화

- & : 주소 구하기 연산자
- &데이터 변수 : 변수의 주소를 의미
- *포인터 변수 : 포인터 변수가 가리키는 주소의 값

```c++
int x = 7;        // 변수의 선언
int *ptr = &x;    // 포인터의 선언
int *pptr = &ptr; // 포인터의 참조
```

## 포인터 이용

### 1. 포인터 다루기

```c++
// 사용자에게 입력받은 해당 값을 2배로 바꿔 출력하기
void ChangeDouble(int* p) {     // int* p = &num;
	*p = *p * 2;

}

int main(void) {
	int num;
	printf("숫자 입력 : ");
	scanf("%d", &num);          // scanf의 &num은 변수 num의 주소라는 의미
	ChangeDouble(&num);
	printf("%d\n", num);
	return 0;
}

```

### 2. 이중 포인터

- 포인터 변수의 주소를 저장하는 포인터 변수
- 이중 포인터를 이용하려면 **처럼 두 번 간접 참조해야 함

```c++
int x;
int *p = &x;
int **pp = &p;  // 이중 포인터
```

### 3. 포인터 오류

- 포인터도 변수이므로 반드시 초기화 해야 함
- 포인터 변수를 초기화하지 않으면 에러 발생
- 널 포인터 : 포인터가 다른 변수를 가리키지 않을 때는 **NULL(0)**로 초기화
- 포인터를 안전하게 사용하려면 널 포인터인지 우선 검사
- 포인터 변수의 데이터 타입은 가리키는 데이터 타입과 일치해야 함

## 포인터 활용

### 1. 포인터로 배열 참조

1. 배열의 시작 주소를 구할 때는 **& 없이 배열명**만 사용
2. 배열의 시작 주소는 첫 번째 원소의 주소와 같음
3. 배열명을 포인터처럼 사용 가능
4. `* (arr+i)`는 `arr[i]`를 의미
5. 배열의 시작 주소로 초기화된 포인터를 이용해 배열의 모든 원소에 접근 가능
6. 포인터 변수를 배열명처럼 사용 가능
7. 포인터와 +, - 연산
    > 데이터 타입의 크기만큼 주소가 증가, 감소함

```c++
`int arr[5]={12,25,37,49,53}; int *p=arr;`

|식|답
|:--|--:
|*p+1|13
|*(p+2)|37
|arr+3|arr[3]의 주소
|*(arr+3)|49
|*arr+4|16
|p[4]|53
|&arr[2]|arr[2]의 주소
|p+3|arr[3]의 주소
```

### 2. 포인터와 배열 원소

1. 배열의 원소를 가리키는 포인터는 **배열의 어떤 원소든 가리킬 수 있음**

```c++
int arr[5] = {10, 20, 30, 40, 50};

int *p = &arr[2];           // p는 arr[2]를 가리킴
printf(“p[0] = %d”, p[0]);  // p[0]은 arr[2]를 의미하므로 30을 출력함
printf(“p[1] = %d”, p[1]);  // p[1]은 arr[3]를 의미하므로 40을 출력함
```

2. 포인터가 배열의 원소가 아닌 일반 변수를 가리킬 때도 `*(p+i) == p[i]`는 항상 성립

```c++
short data = 10;
short *ptr = &data;
ptr[0] = 20;                // *p 대신 p[0]처럼 사용할 수 있음
```

> 배열이 메모리에 할당되고 나면, 배열의 시작 주소 변경 불가
> 포인터 변수는 값을 변경할 수 있으므로, 포인터 변수에 보관된 주소는 변경 가능

## 포인터 연산

포인터에 대한 증감연산도 포인터형에 의해 연산의 결과 결정

> 우선 순위 : p++ > ++p = *

### 1. 포인터 배열 처리

포인터 배열 : 주소를 저장하는 배열

### 2. 포인터 배열의 각 원소에 **배열의 시작 주소**를 저장할 수 있음

```c++
int x[3] = {1, 2, 3};
int y[3] = {4, 5, 6};
int z[3] = {7, 8, 9};
int* arr[3] = {x, y, z};    // 포인터 배열의 원소를 int 배열의 시작 주소로 초기화
```

### 3. arr[i]가 int 배열의 시작 주소로 초기화되었을 때, arr[i]가 가리키는 배열의 원소에 접근하려면 `arr[i][j]`로 기술

```c++
for( i = 0 ; i < 3 ; i++ )
{
    for( j = 0 ; j < 3 ; j++ )
    printf( “%d”, arr[i][j] );  // *(arr[i]+[j])와 같은 의미
    printf( “＼n” );
}
```

## 포인터와 배열

### 1. 2차원 배열과 포인터

`str = str[0] = &str[0][0]`

### 2. 문자형 포인터

문자열 상수를 문자형 포인터 변수에 저장

```c++
// str의 문자열을 거꾸로 출력하기
#include <stdio.h>

int main()
{
	char *str="good morning";
	int i,count=0;
	while(str[i]){
		count++;
	}
	for(i=count-1;i>=0;i--)
		printf("%c",*(str+i));
	return 0;
}
```

## 배열 포인터

배열 포인터는 2차원 배열의 전체를 가리키는 용도로 사용

```c++
int arr[3][5] = {
	{ 1, 2, 3, 4, 5 },
	{ 6, 7, 8, 9, 10},
	{11, 12, 13, 14, 15}
};

int(*p)[5] = &arr[0];	// p를 int 5개 짜리 배열인 arr[0]의 주소로 초기화 함
```

### 1. 배열 포인터를 `&arr[0]`으로 초기화하는 대신, 간단하게 `arr`로 초기화 가능

```c++
int (*p) [5] = arr; // arr는 &arr[0]과 같은 의미임
```

### 2. 배열 포인터 p로 2차원 배열처럼 참조 가능

```c++
int i, j;
for ( i = 0 ; i < 3 ; i++ )
{
	for( j = 0 ; j < 5 ; j++ )
	printf(“%d”, p[i][j]);	// p[i][j]는 원소 arr[i][j]를 의미
	printf(“＼n”);
}
```

### 3. 배열 포인터를 **2차원 배열에 접근하기 위한 용도**로 사용
### 4. 2차원 배열에 대한 배열 포인터는 **열 크기에 따른 변수 선언** 필요

||1차원 배열 포인터|2차원 배열 포인터
|:--:|:--|:--
|선언|데이터 타입 * 포인터 변수명;|데이터 타입(* 포인터 변수명)[크기];
|초기화|변수명 = 배열명;<br />데이터 타입 * 변수명 = 배열명;|변수명 = 배열명;<br />데이터 타입 * 변수명[크기] = 배열명;
|예|int a[3]={1,2,3};<br />int *p=a;<br />p = a;|int a[2][3]={{1,2,3},{4,5,6}};<br />int (*p)[3]=a;<br />p = a;

### 5. 배열 포인터의 증감 연산은 열 크기만큼 이동

## 문자 포인터 배열

### 1. 여러 개의 문자열을 하나로 묶어서 처리하는 방법으로 2차원 문자 배열을 이용

```c++
char str[][6]={ “good”, “nomal”, “bad” };
```

### 2. 여러 개의 문자열을 하나로 묶어서 처리하는 방법으로 문자 포인터 배열을 이용

```c++
char *str[]={ “good”, “nomal”, “bad” };
```